space @N 8
space @head 8
space @startx 8
space @starty 8
space @targetx 8
space @targety 8
space @x 8
space @y 8
space @xlist 8
space @ylist 8
space @tail 8
space @ok 8
space @now 8
space @step 8
space @i 8
space @j 8
asciiz @string no solution!\n

func origin $N {

%origin.entry:
    $newaddress = mul $N 8
    $newaddress = add $newaddress 8
    $newaddress = alloc $newaddress
    store 8 $newaddress $N 0
    @step = move $newaddress
    @i = move 0
    jump %for_cond

%for_cond:
    $t = slt @i $N
    br $t %for_loop %for_after

%for_after:
    ret 0

%for_loop:
    $newaddress_2 = mul $N 8
    $newaddress_2 = add $newaddress_2 8
    $newaddress_2 = alloc $newaddress_2
    store 8 $newaddress_2 $N 0
    $t_2 = mul @i 8
    $t_2 = add @step $t_2
    store 8 $t_2 $newaddress_2 8
    @j = move 0
    jump %for_cond_2

%for_cond_2:
    $t_3 = slt @j $N
    br $t_3 %for_loop_2 %for_after_2

%for_after_2:
    jump %for_step

%for_step:
    $t_4 = move @i
    @i = add @i 1
    jump %for_cond

%for_loop_2:
    $t_5 = mul @i 8
    $t_5 = add @step $t_5
    $t_5 = load 8 $t_5 8
    $t_6 = mul @j 8
    $t_6 = add $t_5 $t_6
    store 8 $t_6 0 8
    jump %for_step_2

%for_step_2:
    $t_7 = move @j
    @j = add @j 1
    jump %for_cond_2

}

func check $a $N {

%check.entry:
    $t = slt $a $N
    br $t %lhs_true %lhs_false

%lhs_false:
    $t_2 = move 0
    jump %lhs_merge

%lhs_true:
    $t_3 = sge $a 0
    $t_2 = move $t_3
    jump %lhs_merge

%lhs_merge:
    ret $t_2

}

func addList $x $y {

%addList.entry:
    $t = call check $x @N 
    br $t %lhs_true_2 %lhs_false_2

%lhs_false_2:
    $t_2 = move 0
    jump %lhs_merge_2

%lhs_true_2:
    $t_3 = call check $y @N 
    $t_2 = move $t_3
    jump %lhs_merge_2

%lhs_merge_2:
    br $t_2 %lhs_true_3 %lhs_false_3

%lhs_true_3:
    $t_4 = mul $x 8
    $t_4 = add @step $t_4
    $t_4 = load 8 $t_4 8
    $t_5 = mul $y 8
    $t_5 = add $t_4 $t_5
    $t_5 = load 8 $t_5 8
    $t_6 = neg 1
    $t_7 = seq $t_5 $t_6
    $t_8 = move $t_7
    jump %lhs_merge_3

%lhs_false_3:
    $t_8 = move 0
    jump %lhs_merge_3

%lhs_merge_3:
    br $t_8 %if_true %if_after

%if_true:
    $t_9 = add @tail 1
    @tail = move $t_9
    $t_10 = mul @tail 8
    $t_10 = add @xlist $t_10
    store 8 $t_10 $x 8
    $t_11 = mul @tail 8
    $t_11 = add @ylist $t_11
    store 8 $t_11 $y 8
    $t_12 = add @now 1
    $t_13 = mul $x 8
    $t_13 = add @step $t_13
    $t_13 = load 8 $t_13 8
    $t_14 = mul $y 8
    $t_14 = add $t_13 $t_14
    store 8 $t_14 $t_12 8
    $t_15 = seq $x @targetx
    br $t_15 %lhs_true_4 %lhs_false_4

%lhs_true_4:
    $t_16 = seq $y @targety
    $t_17 = move $t_16
    jump %lhs_merge_4

%lhs_false_4:
    $t_17 = move 0
    jump %lhs_merge_4

%lhs_merge_4:
    br $t_17 %if_true_2 %if_after_2

%if_true_2:
    @ok = move 1
    jump %if_after_2

%if_after_2:
    jump %if_after

%if_after:
    ret 0

}

func main {

%main.entry:
    call _init 
    $t = call origin 106 
    $gottenint = call getInt 
    @N = move $gottenint
    $t_2 = sub @N 1
    @targety = move $t_2
    @targetx = move @targety
    @i = move 0
    jump %for_cond_3

%for_cond_3:
    $t_3 = slt @i @N
    br $t_3 %for_loop_3 %for_after_3

%for_after_3:
    jump %while_cond

%while_cond:
    $t_4 = sle @head @tail
    br $t_4 %while_loop %while_after

%while_loop:
    $t_5 = mul @head 8
    $t_5 = add @xlist $t_5
    $t_5 = load 8 $t_5 8
    @x = move $t_5
    $t_6 = mul @head 8
    $t_6 = add @ylist $t_6
    $t_6 = load 8 $t_6 8
    @y = move $t_6
    $t_7 = mul @x 8
    $t_7 = add @step $t_7
    $t_7 = load 8 $t_7 8
    $t_8 = mul @y 8
    $t_8 = add $t_7 $t_8
    $t_8 = load 8 $t_8 8
    @now = move $t_8
    $t_9 = sub @x 1
    $t_10 = sub @y 2
    $t_11 = call addList $t_9 $t_10 
    $t_12 = sub @x 1
    $t_13 = add @y 2
    $t_14 = call addList $t_12 $t_13 
    $t_15 = add @x 1
    $t_16 = sub @y 2
    $t_17 = call addList $t_15 $t_16 
    $t_18 = add @x 1
    $t_19 = add @y 2
    $t_20 = call addList $t_18 $t_19 
    $t_21 = sub @x 2
    $t_22 = sub @y 1
    $t_23 = call addList $t_21 $t_22 
    $t_24 = sub @x 2
    $t_25 = add @y 1
    $t_26 = call addList $t_24 $t_25 
    $t_27 = add @x 2
    $t_28 = sub @y 1
    $t_29 = call addList $t_27 $t_28 
    $t_30 = add @x 2
    $t_31 = add @y 1
    $t_32 = call addList $t_30 $t_31 
    $t_33 = seq @ok 1
    br $t_33 %if_true_3 %if_after_3

%if_true_3:
    jump %while_after

%while_after:
    $t_34 = seq @ok 1
    br $t_34 %if_true_4 %if_false

%if_true_4:
    $t_35 = mul @targetx 8
    $t_35 = add @step $t_35
    $t_35 = load 8 $t_35 8
    $t_36 = mul @targety 8
    $t_36 = add $t_35 $t_36
    $t_36 = load 8 $t_36 8
    call printlnint $t_36 
    jump %if_after_4

%if_false:
    call print @string 
    jump %if_after_4

%if_after_4:
    ret 0

%if_after_3:
    $t_37 = add @head 1
    @head = move $t_37
    jump %while_cond

%for_loop_3:
    @j = move 0
    jump %for_cond_4

%for_cond_4:
    $t_38 = slt @j @N
    br $t_38 %for_loop_4 %for_after_4

%for_loop_4:
    $t_39 = neg 1
    $t_40 = mul @i 8
    $t_40 = add @step $t_40
    $t_40 = load 8 $t_40 8
    $t_41 = mul @j 8
    $t_41 = add $t_40 $t_41
    store 8 $t_41 $t_39 8
    jump %for_step_3

%for_step_3:
    $t_42 = move @j
    @j = add @j 1
    jump %for_cond_4

%for_after_4:
    jump %for_step_4

%for_step_4:
    $t_43 = move @i
    @i = add @i 1
    jump %for_cond_3

}

func _init {

%_init.entry:
    @N = move 0
    @head = move 0
    @startx = move 0
    @starty = move 0
    @targetx = move 0
    @targety = move 0
    @x = move 0
    @y = move 0
    $newaddress = move 96008
    $newaddress = alloc $newaddress
    store 8 $newaddress 12000 0
    @xlist = move $newaddress
    $newaddress_2 = move 96008
    $newaddress_2 = alloc $newaddress_2
    store 8 $newaddress_2 12000 0
    @ylist = move $newaddress_2
    @tail = move 0
    @ok = move 0
    @now = move 0
    @step = move 0
    @i = move 0
    @j = move 0
    ret 0

}

