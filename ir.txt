asciiz @string ( 
asciiz @string_2 , 
asciiz @string_3  )
asciiz @string_4 vector x: 
asciiz @string_5 excited!
asciiz @string_6 vector y: 
asciiz @string_7 x + y: 
asciiz @string_8 x * y: 
asciiz @string_9 (1 << 3) * y: 

func vector $this {

%vector.entry:
    ret 0

}

func vector.init $this $vec {

%vector.init.entry:
    $t = seq $vec 0
    br $t %if_true %if_after

%if_after:
    $size = load 8 $vec 0
    $newaddress = mul $size 8
    $newaddress = add $newaddress 8
    $newaddress = alloc $newaddress
    store 8 $newaddress $size 0
    store 8 $this $newaddress 0
    $i = move 0
    $i = move 0
    jump %for_cond

%for_cond:
    $size_2 = load 8 $vec 0
    $t_2 = slt $i $size_2
    br $t_2 %for_loop %for_after

%for_loop:
    $t_3 = mul $i 8
    $t_3 = add $vec $t_3
    $t_3 = load 8 $t_3 8
    $t_4 = load 8 $this 0
    $t_5 = mul $i 8
    $t_5 = add $t_4 $t_5
    store 8 $t_5 $t_3 8
    jump %for_step

%for_step:
    $i = add $i 1
    jump %for_cond

%for_after:
    jump %vector.init.exit

%if_true:
    jump %vector.init.exit

%vector.init.exit:
    ret 0

}

func vector.getDim $this {

%vector.getDim.entry:
    $t = load 8 $this 0
    $t_2 = seq $t 0
    br $t_2 %if_true_2 %if_after_2

%if_after_2:
    $t_3 = load 8 $this 0
    $size = load 8 $t_3 0
    $returnValue = move $size
    jump %vector.getDim.exit

%if_true_2:
    $returnValue = move 0
    jump %vector.getDim.exit

%vector.getDim.exit:
    ret $returnValue

}

func vector.dot $this $rhs {

%vector.dot.entry:
    $i = move 0
    $result = move 0
    jump %while_cond

%while_cond:
    $t = call vector.getDim $this 
    $t_2 = slt $i $t
    br $t_2 %while_loop %while_after

%while_loop:
    $t_3 = load 8 $this 0
    $t_4 = mul $i 8
    $t_4 = add $t_3 $t_4
    $t_4 = load 8 $t_4 8
    $t_5 = load 8 $rhs 0
    $t_6 = mul $i 8
    $t_6 = add $t_5 $t_6
    $t_6 = load 8 $t_6 8
    $t_7 = mul $t_4 $t_6
    $result = move $t_7
    $i = add $i 1
    jump %while_cond

%while_after:
    ret $result

}

func vector.scalarInPlaceMultiply $this $c {

%vector.scalarInPlaceMultiply.entry:
    $t = load 8 $this 0
    $t_2 = seq $t 0
    br $t_2 %if_true_3 %if_after_3

%if_after_3:
    $i = move 0
    $i = move 0
    jump %for_cond_2

%for_cond_2:
    $t_3 = call vector.getDim $this 
    $t_4 = slt $i $t_3
    br $t_4 %for_loop_2 %for_after_2

%for_after_2:
    $returnValue = move $this
    jump %vector.scalarInPlaceMultiply.exit

%for_loop_2:
    $t_5 = load 8 $this 0
    $t_6 = mul $i 8
    $t_6 = add $t_5 $t_6
    $t_6 = load 8 $t_6 8
    $t_7 = mul $c $t_6
    $t_8 = load 8 $this 0
    $t_9 = mul $i 8
    $t_9 = add $t_8 $t_9
    store 8 $t_9 $t_7 8
    jump %for_step_2

%for_step_2:
    $i = add $i 1
    jump %for_cond_2

%if_true_3:
    $returnValue = move 0
    jump %vector.scalarInPlaceMultiply.exit

%vector.scalarInPlaceMultiply.exit:
    ret $returnValue

}

func vector.add $this $rhs {

%vector.add.entry:
    $t = call vector.getDim $this 
    $t_2 = call vector.getDim $rhs 
    $t_3 = sne $t $t_2
    br $t_3 %lhs_true %lhs_false

%lhs_false:
    $t_4 = call vector.getDim $this 
    $t_5 = seq $t_4 0
    $t_6 = move $t_5
    jump %lhs_merge

%lhs_true:
    $t_6 = move 1
    jump %lhs_merge

%lhs_merge:
    br $t_6 %if_true_4 %if_after_4

%if_true_4:
    $returnValue = move 0
    jump %vector.add.exit

%if_after_4:
    $newaddress = alloc 8
    call vector $newaddress 
    $temp = move $newaddress
    $i = move 0
    $t_7 = call vector.getDim $this 
    $newaddress_2 = mul $t_7 8
    $newaddress_2 = add $newaddress_2 8
    $newaddress_2 = alloc $newaddress_2
    store 8 $newaddress_2 $t_7 0
    store 8 $temp $newaddress_2 0
    $i = move 0
    jump %for_cond_3

%for_cond_3:
    $t_8 = call vector.getDim $this 
    $t_9 = slt $i $t_8
    br $t_9 %for_loop_3 %for_after_3

%for_loop_3:
    $t_10 = load 8 $this 0
    $t_11 = mul $i 8
    $t_11 = add $t_10 $t_11
    $t_11 = load 8 $t_11 8
    $t_12 = load 8 $rhs 0
    $t_13 = mul $i 8
    $t_13 = add $t_12 $t_13
    $t_13 = load 8 $t_13 8
    $t_14 = add $t_11 $t_13
    $t_15 = load 8 $temp 0
    $t_16 = mul $i 8
    $t_16 = add $t_15 $t_16
    store 8 $t_16 $t_14 8
    jump %for_step_3

%for_step_3:
    $i = add $i 1
    jump %for_cond_3

%for_after_3:
    $returnValue = move $temp
    jump %vector.add.exit

%vector.add.exit:
    ret $returnValue

}

func vector.set $this $idx $value {

%vector.set.entry:
    $t = call vector.getDim $this 
    $t_2 = slt $t $idx
    br $t_2 %if_true_5 %if_after_5

%if_after_5:
    $t_3 = load 8 $this 0
    $t_4 = mul $idx 8
    $t_4 = add $t_3 $t_4
    store 8 $t_4 $value 8
    $returnValue = move 1
    jump %vector.set.exit

%if_true_5:
    $returnValue = move 0
    jump %vector.set.exit

%vector.set.exit:
    ret $returnValue

}

func vector.tostring $this {

%vector.tostring.entry:
    $temp = move @string
    $t = call vector.getDim $this 
    $t_2 = sgt $t 0
    br $t_2 %if_true_6 %if_after_6

%if_true_6:
    $t_3 = load 8 $this 0
    $t_4 = add $t_3 0
    $t_4 = load 8 $t_4 8
    $tostring = call toString $t_4 
    $t_5 = call string.concat $temp $tostring 
    $temp = move $t_5
    jump %if_after_6

%if_after_6:
    $i = move 0
    $i = move 1
    jump %for_cond_4

%for_cond_4:
    $t_6 = call vector.getDim $this 
    $t_7 = slt $i $t_6
    br $t_7 %for_loop_4 %for_after_4

%for_after_4:
    $t_8 = call string.concat $temp @string_3 
    $temp = move $t_8
    ret $temp

%for_loop_4:
    $t_9 = call string.concat $temp @string_2 
    $t_10 = load 8 $this 0
    $t_11 = mul $i 8
    $t_11 = add $t_10 $t_11
    $t_11 = load 8 $t_11 8
    $tostring_2 = call toString $t_11 
    $t_12 = call string.concat $t_9 $tostring_2 
    $temp = move $t_12
    jump %for_step_4

%for_step_4:
    $i = add $i 1
    jump %for_cond_4

}

func vector.copy $this $rhs {

%vector.copy.entry:
    $t = seq $rhs 0
    br $t %if_true_7 %if_after_7

%if_after_7:
    $t_2 = call vector.getDim $rhs 
    $t_3 = seq $t_2 0
    br $t_3 %if_true_8 %if_false

%if_false:
    $t_4 = call vector.getDim $rhs 
    $newaddress = mul $t_4 8
    $newaddress = add $newaddress 8
    $newaddress = alloc $newaddress
    store 8 $newaddress $t_4 0
    store 8 $this $newaddress 0
    $i = move 0
    $i = move 0
    jump %for_cond_5

%for_cond_5:
    $t_5 = call vector.getDim $this 
    $t_6 = slt $i $t_5
    br $t_6 %for_loop_5 %for_after_5

%for_after_5:
    jump %if_after_8

%for_loop_5:
    $t_7 = load 8 $rhs 0
    $t_8 = mul $i 8
    $t_8 = add $t_7 $t_8
    $t_8 = load 8 $t_8 8
    $t_9 = load 8 $this 0
    $t_10 = mul $i 8
    $t_10 = add $t_9 $t_10
    store 8 $t_10 $t_8 8
    jump %for_step_5

%for_step_5:
    $i = add $i 1
    jump %for_cond_5

%if_true_8:
    store 8 $this 0 0
    jump %if_after_8

%if_after_8:
    $returnValue = move 1
    jump %vector.copy.exit

%if_true_7:
    $returnValue = move 0
    jump %vector.copy.exit

%vector.copy.exit:
    ret $returnValue

}

func main {

%main.entry:
    call _init 
    $newaddress = alloc 8
    call vector $newaddress 
    $x = move $newaddress
    $newaddress_2 = move 88
    $newaddress_2 = alloc $newaddress_2
    store 8 $newaddress_2 10 0
    $a = move $newaddress_2
    $i = move 0
    $i = move 0
    jump %for_cond_6

%for_cond_6:
    $t = slt $i 10
    br $t %for_loop_6 %for_after_6

%for_loop_6:
    $t_2 = sub 9 $i
    $t_3 = mul $i 8
    $t_3 = add $a $t_3
    store 8 $t_3 $t_2 8
    jump %for_step_6

%for_step_6:
    $i = add $i 1
    jump %for_cond_6

%for_after_6:
    $t_4 = call vector.init $x $a 
    call print @string_4 
    $t_5 = call vector.tostring $x 
    call println $t_5 
    $newaddress_3 = alloc 8
    call vector $newaddress_3 
    $y = move $newaddress_3
    $t_6 = call vector.copy $y $x 
    $t_7 = call vector.set $y 3 817 
    br $t_7 %if_true_9 %if_after_9

%if_true_9:
    call println @string_5 
    jump %if_after_9

%if_after_9:
    call print @string_6 
    $t_8 = call vector.tostring $y 
    call println $t_8 
    call print @string_7 
    $t_9 = call vector.add $x $y 
    $t_10 = call vector.tostring $t_9 
    call println $t_10 
    call print @string_8 
    $t_11 = call vector.dot $x $y 
    call printlnint $t_11 
    call print @string_9 
    $t_12 = call vector.scalarInPlaceMultiply $y 8 
    $t_13 = call vector.tostring $t_12 
    call println $t_13 
    ret 0

}

func _init {

%_init.entry:
    ret 0

}

